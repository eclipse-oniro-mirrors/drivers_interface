/*
 * Copyright (c) 2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ohos.hdi.codec.v1_0;
sequenceable OHOS.HDI.Display.BufferHandleParcelable;

enum CodecType {
    VIDEO_DECODER,
    VIDEO_ENCODER,
    AUDIO_DECODER,
    AUDIO_ENCODER,
    INVALID_TYPE,
};
enum AvCodecRole {
    MEDIA_ROLETYPE_IMAGE_JPEG = 0,
    MEDIA_ROLETYPE_VIDEO_AVC,
    MEDIA_ROLETYPE_VIDEO_HEVC,
    MEDIA_ROLETYPE_AUDIO_FIRST = 0x10000,
    MEDIA_ROLETYPE_AUDIO_AAC = 0x10000,
    MEDIA_ROLETYPE_AUDIO_G711A,
    MEDIA_ROLETYPE_AUDIO_G711U,
    MEDIA_ROLETYPE_AUDIO_G726,
    MEDIA_ROLETYPE_AUDIO_PCM,
    MEDIA_ROLETYPE_AUDIO_MP3,
    MEDIA_ROLETYPE_INVALID,
};
enum Profile {
    INVALID_PROFILE = 0,
    AAC_LC_PROFILE = 0x1000,
    AAC_MAIN_PROFILE,
    AAC_HE_V1_PROFILE,
    AAC_HE_V2_PROFILE,
    AAC_LD_PROFILE,
    AAC_ELD_PROFILE,
    AVC_BASELINE_PROFILE = 0x2000,
    AVC_MAIN_PROFILE,
    AVC_HIGH_PROFILE,
    HEVC_MAIN_PROFILE = 0x3000,
    HEVC_MAIN_10_PROFILE,
};
enum CodecCapsMask {
    CODEC_CAP_ADAPTIVE_PLAYBACK = 0x1,
    CODEC_CAP_SECURE_PLAYBACK = 0x2,
    CODEC_CAP_TUNNEL_PLAYBACK = 0x4,
    CODEC_CAP_MULTI_PLANE = 0x10000,
};
enum AudioSampleRate {
    AUD_SAMPLE_RATE_8000 = 8000,
    AUD_SAMPLE_RATE_12000 = 12000,
    AUD_SAMPLE_RATE_11025 = 11025,
    AUD_SAMPLE_RATE_16000 = 16000,
    AUD_SAMPLE_RATE_22050 = 22050,
    AUD_SAMPLE_RATE_24000 = 24000,
    AUD_SAMPLE_RATE_32000 = 32000,
    AUD_SAMPLE_RATE_44100 = 44100,
    AUD_SAMPLE_RATE_48000 = 48000,
    AUD_SAMPLE_RATE_64000 = 64000,
    AUD_SAMPLE_RATE_96000 = 96000,
    AUD_SAMPLE_RATE_INVALID,
};
enum CodecAudioSampleFormat {
    AUDIO_SAMPLE_FMT_U8 = 0,
    AUDIO_SAMPLE_FMT_S16,
    AUDIO_SAMPLE_FMT_S32,
    AUDIO_SAMPLE_FMT_FLOAT,
    AUDIO_SAMPLE_FMT_DOUBLE,
    AUDIO_SAMPLE_FMT_U8P,
    AUDIO_SAMPLE_FMT_S16P,
    AUDIO_SAMPLE_FMT_S32P,
    AUDIO_SAMPLE_FMT_FLOATP,
    AUDIO_SAMPLE_FMT_DOUBLEP,
    AUDIO_SAMPLE_FMT_INVALID,
};
enum CodecProcessMode {
    PROCESS_BLOCKING_INPUT_BUFFER = 0x1,
    PROCESS_BLOCKING_OUTPUT_BUFFER = 0x2,
    PROCESS_BLOCKING_CONTROL_FLOW = 0x4,
    PROCESS_NONBLOCKING_INPUT_BUFFER = 0x100,
    PROCESS_NONBLOCKING_OUTPUT_BUFFER = 0x200,
    PROCESS_NONBLOCKING_CONTROL_FLOW = 0x400,
};
enum ShareMemTypes {
    READ_WRITE_TYPE = 0x1,
    READ_ONLY_TYPE = 0x2,
};
enum BitRateMode {
    BIT_RATE_MODE_INVALID,
    BIT_RATE_MODE_VBR,
    BIT_RATE_MODE_CBR,
    BIT_RATE_MODE_CQ,
    BIT_RATE_MODE_VCBR,
    BIT_RATE_MODE_ABR,
};

enum OMX_EVENTTYPE {
    OMX_EventCmdComplete,
    OMX_EventError,
    OMX_EventMark,
    OMX_EventPortSettingsChanged,
    OMX_EventBufferFlag,
    OMX_EventResourcesAcquired,
    OMX_EventComponentResumed,
    OMX_EventDynamicResourcesAvailable,
    OMX_EventPortFormatDetected,
    OMX_EventKhronosExtensions = 0x6F000000,
    OMX_EventVendorStartUnused = 0x7F000000,
    OMX_EventMax = 0x7FFFFFFF,
};

enum OMX_COMMANDTYPE
{
    OMX_CommandStateSet,
    OMX_CommandFlush,
    OMX_CommandPortDisable,
    OMX_CommandPortEnable,
    OMX_CommandMarkBuffer,
    OMX_CommandKhronosExtensions = 0x6F000000,
    OMX_CommandVendorStartUnused = 0x7F000000,
    OMX_CommandMax = 0x7FFFFFFF,
};

enum OMX_STATETYPE
{
    OMX_StateInvalid,
    OMX_StateLoaded,
    OMX_StateIdle,
    OMX_StateExecuting,
    OMX_StatePause,
    OMX_StateWaitForResources,
    OMX_StateKhronosExtensions = 0x6F000000,
    OMX_StateVendorStartUnused = 0x7F000000,
    OMX_StateMax = 0x7FFFFFFF,
};

enum OMX_BUFFERSUPPLIERTYPE
{
    OMX_BufferSupplyUnspecified = 0,
    OMX_BufferSupplyInput,
    OMX_BufferSupplyOutput,
    OMX_BufferSupplyKhronosExtensions = 0x6F000000,
    OMX_BufferSupplyVendorStartUnused = 0x7F000000,
    OMX_BufferSupplyMax = 0x7FFFFFFF,
};

struct Alignment {
    int widthAlignment;
    int heightAlignment;
};
struct Rect {
    int width;
    int height;
};
struct RangeValue {
    int min;
    int max;
};

struct CodecVideoPortCap {
    struct Rect minSize;
    struct Rect maxSize;
    struct Alignment whAlignment;
    struct RangeValue blockCount;
    struct RangeValue blocksPerSecond;
    struct Rect blockSize;
    int[] supportPixFmts;
    enum BitRateMode[] bitRatemode;
    struct RangeValue frameRate;
    int[] measuredFrameRate;
};

struct CodecAudioPortCap {
    int[] sampleFormats;
    int[] sampleRate;
    int[] channelLayouts;
    int[] channelCount;
};

struct PortCap {
    struct CodecVideoPortCap video;
    struct CodecAudioPortCap audio;
};
struct OmxVerType {
    unsigned char nVersionMajor;
    unsigned char nVersionMinor;
    unsigned char nRevision;
    unsigned char nStep;
};
union OMX_VERSIONTYPE {
    struct OmxVerType s;
    unsigned int nVersion;
};

struct CodecCompCapability {
    enum AvCodecRole role;
    enum CodecType type;
    String compName;
    int[] supportProfiles;
    int maxInst;
    boolean isSoftwareCodec;
    int processModeMask;
    unsigned int capsMask;
    struct RangeValue bitRate;
    struct PortCap port;
};

struct OmxCodecBuffer {
    unsigned int bufferId;
    unsigned int size;
    union OMX_VERSIONTYPE version;
    unsigned int bufferType;
    BufferHandleParcelable bufferhandle;
    FileDescriptor fd;
    unsigned int allocLen;
    unsigned int filledLen;
    unsigned int offset;
    FileDescriptor fenceFd;
    enum ShareMemTypes type;
    long pts;
    unsigned int flag;
};

struct OMX_TUNNELSETUPTYPE {
    unsigned int nTunnelFlags;
    enum OMX_BUFFERSUPPLIERTYPE eSupplier;
};

struct CompVerInfo {
    String compName;
    unsigned char[] compUUID;
    union OMX_VERSIONTYPE compVersion;
    union OMX_VERSIONTYPE specVersion;
};

struct EventInfo {
    long appData;
    unsigned int data1;
    unsigned int data2;
    byte[] eventData;
};