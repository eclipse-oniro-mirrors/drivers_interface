/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @addtogroup Ril
 *
 * @brief Defines Ril-related APIs.
 *
 * The radio interface layer (RIL) module provides APIs and callbacks for upper-layer telephony services,
 * including call, SMS, MMS, network search, and SIM card services.
 *
 * @since 4.1
 * @version 2.0
 */

package ohos.hdi.ril.v2_0;

/**
 * @brief Slice/Service Type as defined in 3GPP TS 23.501.
 */
enum SliceServiceType {
    /**
     * Not specified
     */
    NONE = 0,

    /**
     * Slice suitable for the handling of 5G enhanced Mobile Broadband
     */
    EMBB = 1,

    /**
     * Slice suitable for the handling of ultra-reliable low latency communications
     */
    URLLC = 2,

    /**
     * Slice suitable for the handling of massive IoT
     */
    MIOT = 3,
};

/**
 * @brief Enumeratesthe the current status of the slice.
 */
enum SliceStatus {
    /**
     * Unknown
     */
    UNKNOWN,

    /**
     * Configured but not allowed or rejected yet
     */
    CONFIGURED,

    /**
     * Allowed to be used
     */
    ALLOWED,

    /**
     * Rejected because not available in PLMN
     */
    REJECTED_NOT_AVAILABLE_IN_PLMN,

    /**
     * Rejected because not available in reg area
     */
    REJECTED_NOT_AVAILABLE_IN_REG_AREA,

    /**
     * Considered valid when configured/allowed slices are not available
     */
    DEFAULT_CONFIGURED,
};

/**
 * @brief Enumerates the request reason.
 */
enum DataRequestReason {
    /**
     * The reason of the data request is normal
     */
    NORMAL = 1,
    /**
     * The reason of the data request is device shutdown
     */
    SHUTDOWN = 2,
    /**
     * The reason of the data request is IWLAN data handover to another transport
     * (e.g. from cellular to wifi or vise versa)
     */
    HANDOVER = 3,
};

/**
 * @brief This struct represents a S-NSSAI as defined in 3GPP TS 24.501.
 */
struct SliceInfo {
    /**
     * The type of service provided by the slice.
     *
     * For details，see 3GPP TS 24.501 Section 9.11.2.8.
     */
    enum SliceServiceType sst;

    /**
     * Slice differentiator is the identifier of a slice that has SliceServiceType as SST. 
     * A value of -1 indicates that there is no corresponding SliceInfo of the HPLMN.
     *
     * For details，see 3GPP TS 24.501 Section 9.11.2.8.
     */
    int sliceDifferentiator;

    /**
     * This SST corresponds to a SliceInfo (S-NSSAI) of the HPLMN; the SST is mapped to this value.
     *
     * For details，see 3GPP TS 24.501 Section 9.11.2.8.
     */
    enum SliceServiceType mappedHplmnSst;

    /**
     * Present only if both sliceDifferentiator and mappedHplmnSst are also present.
     * This SD corresponds to a SliceInfo (S-NSSAI) of the HPLMN;
     * sliceDifferentiator is mapped to this value.
     * A value of -1 indicates that there is no corresponding SliceInfo of the HPLMN.
     *
     * For details，see 3GPP TS 24.501 Section 9.11.2.8.
     */
    int mappedHplmnSD;

    /**
     * Field to indicate the current status of the slice.
     */
    enum SliceStatus status;
};

/**
 * @brief Defines the optional slice information.
 */
union OptionalSliceInfo {
    /**
     * A S-NSSAI as defined in 3GPP TS 24.501.
     */
    struct SliceInfo value;
};

/**
 * @brief Defines data network name and represents an APN as defined in 3GPP TS 23.003.
 */
struct OptionalDnn {
    String val;
};

/**
 * @brief The OsId + OsAppId as defined in TS 24.526 Section 5.2
 */
struct OsAppId {
    /**
     * OsId + OsAppId. The minimum length of the array is 18 and
     * maximum length is 272 (16 bytes for OsId + 1 byte for OsAppId length
     * + up to 255 bytes for OsAppId).
     */
    String osAppId;
};

/**
 * @brief Defines OsAppId.
 */
struct OptionalOsAppId {
    /**
     * A S-NSSAI as defined in 3GPP TS 24.501.
     */
    struct OsAppId value;
};

/**
 * @brief Defines the traffic descriptor. A valid struct must have at least
 * one of the optional values present. This is based on the definition of traffic
 * descriptor in TS 24.526 Section 5.2.
 */
struct TrafficDescriptor {
    /**
     * DNN stands for Data Network Name and represents an APN as defined in
     * 3GPP TS 23.003.
     */
    struct OptionalDnn dnn;

    /**
     * Indicates the OsId + OsAppId.
     */
    struct OptionalOsAppId osAppId;
};

/**
 * @brief Defines the optional TrafficDescriptor.
 */
struct OptionalTrafficDescriptor {
    /**
     * Traffic descriptor
     */
    struct TrafficDescriptor des;
};

/**
 * @brief Enumeratesthe the APN types.
 */
enum ApnTypes {
    /**
     * None
     */
    NONETYPE = 0,     
    
    /**
     * Default data traffic
     */
    DEFAULT = 1 << 0,

    /**
     * Default MMS traffic
     */
    MMS = 1 << 1,

    /**
     * Default SUPL assisted GPS
     */
    SUPL = 1 << 2,

    /**
     * Default DUN traffic
     */
    DUN = 1 << 3,

    /**
     * Default HiPri traffic
     */
    HIPRI = 1 << 4,

    /**
     * Default FOTA
     */
    FOTA = 1 << 5,

    /**
     * Default IMS
     */
    IMS = 1 << 6,

    /**
     * Default CBS
     */
    CBS = 1 << 7,

    /**
     * Initial Attach APN
     */
    IA = 1 << 8,

    /**
     * Emergency PDN. This is not an initial attach apn, 
     * but is used for access to carrier services in an emergency call situation.
     */
    EMERGENCY = 1 << 9,

    /**
     * APN type for Mission Critical Service
     * Reference: 3GPP TS 22.280 V15.3.0
     */
    MCX = 1 << 10,

    /**
     *  XCAP APN
     */
    XCAP = 1 << 11,
};

/**
 * @brief Defines PDP context information.
 */
struct DataProfileDataInfo {
    /**
     * Request SN
     */
    int serial;

    /**
     * Data service type. The value 0 indicates the default data service,
     * and the value 1 indicates the MMS data service.
     */
    int profileId;

    /**
     * Authentication mode:
     *- 0: no authentication
     *- 1: Password Authentication Protocol (PAP)
     *- 2: Challenge Handshake Authentication Protocol (CHAP)
     */
    int authenticationType;

    /**
     * Access point name
     */
    String apn;

    /**
     * Protocol version
     */
    String protocol;

    /**
     * Roaming protocol version
     */
    String roamingProtocol;

    /**
     * Username
     */
    String userName;

    /**
     * Password
     */
    String password;

    /**
     * Supported APN types Bitmap
     */
    unsigned long supportedApnTypesBitmap;
};

/**
 * @brief Defines the data service information.
 */
struct DataCallInfo {
    /**
     * Request SN
     */
    int serial;

    /**
     * Radio access technology. For details, see {@link RilRadioTech}.
     */
    int radioTechnology;

    /**
     * Whether the PDP context is set for the modem
     */
    boolean modemCognitive;

    /**
     * Whether roaming is allowed. The value true indicates that roaming is allowed,
     * and the value false indicates the opposite.
     */
    boolean roamingAllowed;

    /**
     * Whether the user is roaming. The value true indicates that the user is roaming,
     * and the value false indicates the opposite.
     */
    boolean isRoaming;

    /**
     * PDP context information
     */
    struct DataProfileDataInfo dataProfileInfo;

    /**
     * The request reason. Must be DataRequestReason:NORMAL or DataRequestReason:HANDOVER.
     */
    enum DataRequestReason reason;

    /**
     * The pdu session id to be used for this data call.
     * A value of 0 means no pdu session id was attached to this call.
     */
    int pduSessionId;

    /**
     * SliceInfo to be used for the data connection when a handover occurs from EPDG to 5G.
     * It is valid only when accessNetwork is AccessNetwork:NGRAN.
     * If the slice passed from EPDG is rejected, then the data failure cause must be
     * DataCallFailCause:SLICE_REJECTED.
     */
    union OptionalSliceInfo sliceInfo;

    /**
     * TrafficDescriptor for which data connection needs to be established.
     * It is used for URSP traffic matching as described in TS 24.526 Section 4.2.2.
     * It includes an optional DNN which, if present, must be used for traffic matching
     * -- it does not specify the end point to be used for the data call.
     * The end point is specified by DataProfileInfo.apn;
     * DataProfileInfo.apn must be used as the end point if one is not specified through URSP rules.
     */
    struct OptionalTrafficDescriptor trafficDescriptor;

    /**
     * Indicate if using default match-all URSP rule for this request is allowed.
     * If false, this request must not use the match-all URSP rule and 
     * if a non-match-all rule is not found (or if URSP rules are not available) it should return
     * failure with cause DataCallFailCause:MATCH_ALL_RULE_NOT_ALLOWED. This is needed as some
     * requests need to have a hard failure if the intention cannot be met, for example, a
     * zero-rating slice.
     */
    boolean matchAllRuleAllowed;
};

struct QosBandwidth {
    /** 
     * Maximum bit rate possible on the bearer
     */
    int maxBitrateKbps;
    /** 
     *Minimum bit rate that is guaranteed to be provided by the network
     */
    int guaranteedBitrateKbps;
};

/**
 * @brief LTE/EPS Quality of Service parameters as per 3gpp spec 24.301 sec 9.9.4.3.
 */
struct EpsQos {
    /**
     * Quality of Service Class Identifier (QCI), see 3GPP TS 23.203 and 29.212.
     * The allowed values are standard values(1-9, 65-68, 69-70, 75, 79-80, 82-85)
     * defined in the spec and operator specific values in the range 128-254.
     */
    int qci;
    QosBandwidth downlink;
    QosBandwidth uplink;
};

/**
 * @brief 5G Quality of Service parameters as per 3gpp spec 24.501 sec 9.11.4.12.
 */
struct NrQos {
    /**
     * 5G QOS Identifier (5QI), see 3GPP TS 24.501 and 23.501.
     * The allowed values are standard values(1-9, 65-68, 69-70, 75, 79-80, 82-85)
     * defined in the spec and operator specific values in the range 128-254.
     */
    int fiveQi;
    QosBandwidth downlink;
    QosBandwidth uplink;
    /**
     * QOS flow identifier of the QOS flow description in the
     * range of QosFlowIdRange::MIN to QosFlowIdRange::MAX
     */
    int qfi;
    int averagingWindowMs;
};

/** 
 * @brief EPS or NR QOS parameters.
 */
union Qos {
    struct EpsQos eps;
    struct NrQos nr;
};

/**
 * Defines range of ports. start and end are the first and last port numbers
 * (inclusive) in the range. Both start and end are in QosPortRange.MIN to
 * QosPortRange.MAX range. A single port shall be represented by the same
 * start and end value.
 */
struct PortRange {
    int start;
    int end;
};

/**
 * Port is optional, contains either single port or range of ports.
 */
union MaybePort {
    PortRange range;
};

/**
 * Next header protocol numbers defined by IANA, RFC 5237
 */
enum QosProtocol {
    /**
     * No protocol specified
     */
    UNSPECIFIED = -1,
    /**
     * Transmission Control Protocol
     */
    TCP = 6,
    /**
     * User Datagram Protocol
     */
    UDP = 17,
    /**
     * Encapsulating Security Payload Protocol
     */
    ESP = 50,
    /**
     * Authentication Header
     */
    AH = 51,
};

/**
 * Type of service value or mask as defined in RFC 1349
 */
union TypeOfService {
    int value;
};

/**
 * IPv6 flow label as defined in RFC 6437
 */
union Ipv6FlowLabel {
    int value;
};

/**
 * IPSec security parameter index
 */
union IpsecSpi {
    int value;
};

enum QosFilterDirection {
    DOWNLINK = 0,
    UPLINK = 1,
    BIDIRECTIONAL = 2,
};

/**
 * See 3gpp 24.008 10.5.6.12 and 3gpp 24.501 9.11.4.13.
 */
struct QosFilter {
    /**
     * Local and remote IP addresses, typically one IPv4 or one IPv6
     * or one of each. Addresses could be with optional "/" prefix
     * length, e.g.,"192.0.1.3" or "192.0.1.11/16 2001:db8::1/64".
     * If the prefix length is absent the addresses are assumed to be
     * point to point with IPv4 having a prefix length of 32 and
     * IPv6 128.
     */
    String[] localAddresses;
    String[] remoteAddresses;

    /**
     * Local and remote port/ranges
     */
    union MaybePort localPort;
    union MaybePort remotePort;

    /**
     * QoS protocol
     */
    enum QosProtocol protocol;

    /**
     * Type of service
     */
    union TypeOfService tos;

    /**
     * IPv6 flow label
     */
    union Ipv6FlowLabel flowLabel;

    /**
     * IPSec security parameter index
     */
    union IpsecSpi spi;

    /**
     * Filter direction
     */
    QosFilterDirection direction;

    /**
     * Specifies the order in which the filter needs to be matched.
     * A lower numerical(positive) value has a higher precedence.
     * Set -1 when unspecified.
     */
    int precedence;
};

/**
 * @brief QOS session associated with a dedicated bearer.
 */
struct QosSession {
    /**
     * Unique ID of the QoS session within the data call
     */
    int qosSessionId;

    /**
     * QOS attributes
     */
    Qos qos;

    /**
     * List of QOS filters associated with this session
     */
    QosFilter[] qosFilters;
};

/**
 * @brief The allowed failure modes on an IWLAN handover failure.
 */
enum HandoverFailureMode {
    /**
     * On data handover failure, fallback to the source data transport when the
     * fail cause is due to a hand off preference change.
     */
    LEGACY = 0,

    /** On data handover failure, fallback to the source data transport. */
    DO_FALLBACK = 1,

    /**
     * On data handover failure, retry the handover instead of falling back to
     * the source data transport.
     */
    NO_FALLBACK_RETRY_HANDOVER = 2,

    /**
     * On data handover failure, setup a new data connection by sending a normal
     * request to the underlying data service.
     */
    NO_FALLBACK_RETRY_SETUP_NORMAL = 3
};

/**
 * @brief Defines the data service activation result.
 */
struct SetupDataCallResultInfo {
    /**
     * Activation result ID
     */
    int flag;

    /**
     * Reason code of the data service activation failure. For details, see 3GPP TS 24.008.
     */
    int reason;

    /**
     * Number of data service activation retry times
     */
    int retryTime;

    /**
     * Packet Data Protocol (PDP) context ID
     */
    int cid;

    /**
     * Whether the activation is successful. The value 0 indicates that the activation fails,
     * and the value 1 indicates that the activation is successful.
     */
    int active;

    /**
     * MTU received from network for IPv4.
     * Value <= 0 means network has either not sent a value or sent an invalid value.
     */
    int mtuV4;

    /**
     * MTU received from network for IPv6.
     * Value <= 0 means network has either not sent a value or sent an invalid value.
     */
    int mtuV6;

    /**
     * Data unit ID
     */
    int pduSessionId;

    /**
     * Data service type. The value default indicates the default data service,
     * and the value mms indicates the MMS data service.
     */
    String type;

    /**
     * Network port name
     */
    String netPortName;

    /**
     * Network address
     */
    String address;

    /**
     * IP address of the primary DNS server
     */
    String dns;

    /**
     * IP address of the secondary DNS server.
     */
    String dnsSec;

    /**
     * Gateway address
     */
    String gateway;

    /**
     * IP address of the primary Proxy-Call Session Control Function (P-CSCF)
     */
    String pCscfPrimAddr;

    /**
     * IP address of the secondary P-CSCF
     */
    String pCscfSecAddr;

    /** 
     * Default bearer QoS. Applicable to LTE and NR
     */
    union Qos defaultQos;

    /**
     * Active QOS sessions of the dedicated bearers. Applicable to
     * PDNs that support dedicated bearers.
     */
    QosSession[] qosSessions;

    /**
     * Specifies the fallback mode on an IWLAN handover failure.
     */
    enum HandoverFailureMode handoverFailureMode;

    /**
     * Slice used for this data call. It is valid only when this data call is on
     * AccessNetwork:NGRAN.
     */
    union OptionalSliceInfo sliceInfo;

    /**
     * TrafficDescriptors for which this data call must be used. It only includes
     * the TDs for which a data call has been requested so far; it is not an
     * exhaustive list.
     */
    TrafficDescriptor[] trafficDescriptors;
};

/**
 * @brief Enumerates Ril error codes.
 */
enum RilErrType {
    /**
     * Call success
     */
    RIL_NONE = 0,

    /**
     * Common error
     */
    RIL_ERR_GENERIC_FAILURE = 1,

    /**
     * Invalid parameters
     */
    RIL_ERR_INVALID_PARAMETER = 2,

    /**
     * Memory fully loaded
     */
    RIL_ERR_MEMORY_FULL = 3,

    /**
     * Command sending failed
     */
    RIL_ERR_CMD_SEND_FAILURE = 4,

    /**
     * Command connection terminated
     */
    RIL_ERR_CMD_NO_CARRIER = 5,

    /**
     * Invalid response
     */
    RIL_ERR_INVALID_RESPONSE = 6,

    /**
     * Status repeated
     */
    RIL_ERR_REPEAT_STATUS = 7,

    /**
     * Network search in progress
     */
    RIL_ERR_NETWORK_SEARCHING = 8,

    /**
     * Network search interrupted
     */
    RIL_ERR_NETWORK_SEARCHING_INTERRUPTED = 9,

    /**
     * Modem shut down
     */
    RIL_ERR_MODEM_DEVICE_CLOSE = 10,

    /**
     * SIM card not inserted
     */
    RIL_ERR_NO_SIMCARD_INSERTED = 11,

    /**
     * PIN required
     */
    RIL_ERR_NEED_PIN_CODE = 12,

    /**
     * PUK required
     */
    RIL_ERR_NEED_PUK_CODE = 13,

    /**
     * Network search timed out
     */
    RIL_ERR_NETWORK_SEARCH_TIMEOUT = 14,

    /**
     * Incorrect PIN or PUK
     */
    RIL_ERR_PINPUK_PASSWORD_NOCORRECT = 15,

    /**
     * Modem parameter error
     */
    RIL_ERR_INVALID_MODEM_PARAMETER = 50,

    /**
     * IPC error
     */
    RIL_ERR_HDF_IPC_FAILURE = 300,

    /**
     * Null pointer
     */
    RIL_ERR_NULL_POINT = 301,

    /**
     * Vendor library not implemented
     */
    RIL_ERR_VENDOR_NOT_IMPLEMENT = 302
};

/**
 * @brief Enumerates response types.
 */
enum RilResponseTypes {
    /**
     * Request response
     */
    RIL_RESPONSE_REQUEST = 0,

    /**
     * Notification response
     */
    RIL_RESPONSE_NOTICE = 1,

    /**
     * Acknowledgment request response
     */
    RIL_RESPONSE_REQUEST_ACK = 2,

    /**
     * Response to a request that must be acknowledged
     */
    RIL_RESPONSE_REQUEST_MUST_ACK = 3,

    /**
     * Response to a notification that must be acknowledged
     */
    RIL_RESPONSE_NOTICE_MUST_ACK = 4,
};

/**
 * @brief Defines the common response information.
 */
struct RilRadioResponseInfo {
    /**
     * Card slot ID
     */
    int slotId;

    /**
     * Response flag
     */
    int flag;

    /**
     * Request SN
     */
    int serial;

    /**
     * Error code
     */
    enum RilErrType error;

    /**
     * Response type. For details, see {@link RilResponseTypes}.
     */
    enum RilResponseTypes type;
};